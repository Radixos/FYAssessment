// first step of tesselation shader
// tesselation control shader add/deletes control points and determines the tesselatation level
// patch has three control points here (three vertices for each triangle)


#version 450 core
layout (vertices = 3) out;


// vectors stored as arrays - each patch has three vertices, each with an xyz pos and xyz norm value 
//posVS = position from Vertex Shader, posTC = position from this Tesselation Control shader

in vec3 FragPos[];
in vec2 TexCoords[];

uniform vec3 eyePos;
uniform float lambda;
uniform float alpha;

out vec3 FragPosTC[];
out vec2 TexCoordsTC[];

float GetTessLevel(float dist1, float dist2)
{
	float tessLevel = 0.f;
	float avgDist = (dist1 + dist2)/2;

	float equation = lambda * avgDist;

	tessLevel = round(exp(equation) * alpha);

	if (avgDist < 1.f)
		return 1;
	return tessLevel;
}

void main()
{
	int tessLevel = 1;
	
	float eyeToVertexDist1 = distance(eyePos, FragPos[1]);
	float eyeToVertexDist2 = distance(eyePos, FragPos[2]);
	float eyeToVertexDist0 = distance(eyePos, FragPos[0]);

   // gpu can calculate each control point in parallel
   // tesselation level same for entire patch so only need to set it once (for the first control point)
   // gl_invocation called for each control point
   if (gl_InvocationID==0)
   {
		// Calculate the tessellation levels
        gl_TessLevelOuter[0] = GetTessLevel(eyeToVertexDist1, eyeToVertexDist2); 
        gl_TessLevelOuter[1] = GetTessLevel(eyeToVertexDist2, eyeToVertexDist0); 
        gl_TessLevelOuter[2] = GetTessLevel(eyeToVertexDist0, eyeToVertexDist1);
        gl_TessLevelInner[0] = gl_TessLevelOuter[2]; 
   }

   // pass through position and normal information
   FragPosTC[gl_InvocationID]  = FragPos[gl_InvocationID];
   TexCoordsTC[gl_InvocationID] = TexCoords[gl_InvocationID];
}